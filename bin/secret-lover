#!/bin/bash
#
# secret-lover - The one who keeps your secrets
# Credential broker for macOS Keychain with Touch ID
#

set -e

SERVICE="secret-lover"
LOG_DIR="$HOME/.secret-lover"
LOG_FILE="$LOG_DIR/access.log"

# Ensure log directory exists
mkdir -p "$LOG_DIR"

log_access() {
    local action="$1"
    local name="$2"
    local status="$3"
    local tty_name
    tty_name=$(tty 2>/dev/null) || tty_name="none"
    echo "$(date -Iseconds) | $action | $name | $status | pid=$$ | tty=$tty_name" >> "$LOG_FILE"
}

show_help() {
    cat << 'EOF'
secret-lover - The one who keeps your secrets

COMMANDS:
  secret-lover add NAME [VALUE]   Add a secret (prompts if VALUE omitted)
  secret-lover get NAME           Retrieve a secret (requires Touch ID)
  secret-lover list               List all stored secret names
  secret-lover delete NAME        Remove a secret
  secret-lover check              Check if Touch ID is available
  secret-lover help               Show this help

PROJECT COMMANDS:
  secret-lover run -- <command>   Run command with .secrets.json injected
  secret-lover init               Create .secrets.json template
  secret-lover verify             Check all project secrets exist

EXAMPLES:
  secret-lover add OPENAI_API_KEY
  secret-lover add DATABASE_URL "postgres://localhost/mydb"
  secret-lover get ANTHROPIC_API_KEY
  secret-lover run -- npm run dev
  secret-lover run -- claude

SECURITY:
  - Secrets stored in macOS Keychain (login keychain)
  - Touch ID or password required for retrieval
  - All access logged to ~/.secret-lover/access.log
  - Secrets never written to disk or shell history

EOF
}

cmd_add() {
    local name="$1"
    local value="$2"

    if [[ -z "$name" ]]; then
        echo "Usage: secret-lover add NAME [VALUE]" >&2
        exit 1
    fi

    # If no value provided, prompt securely
    if [[ -z "$value" ]]; then
        echo -n "Enter value for $name: "
        read -s value
        echo

        if [[ -z "$value" ]]; then
            echo "Error: Empty value not allowed" >&2
            exit 1
        fi
    fi

    # Delete existing if present (silently)
    security delete-generic-password -a "$name" -s "$SERVICE" 2>/dev/null || true

    # Add to keychain
    # -T "" prevents automatic access - will prompt for auth
    if security add-generic-password -a "$name" -s "$SERVICE" -w "$value" -T "" 2>/dev/null; then
        log_access "ADD" "$name" "success"
        echo "✓ Stored: $name"
    else
        log_access "ADD" "$name" "failed"
        echo "✗ Failed to store: $name" >&2
        exit 1
    fi
}

cmd_get() {
    local name="$1"

    if [[ -z "$name" ]]; then
        echo "Usage: secret-lover get NAME" >&2
        exit 1
    fi

    # Retrieve from keychain - this will trigger Touch ID/password prompt
    local value
    if value=$(security find-generic-password -a "$name" -s "$SERVICE" -w 2>/dev/null); then
        log_access "GET" "$name" "success"
        echo "$value"
    else
        log_access "GET" "$name" "not_found"
        echo "Error: Secret '$name' not found" >&2
        exit 1
    fi
}

cmd_list() {
    echo "Secrets stored in Keychain:"
    echo

    # Find all items with our service name using awk
    security dump-keychain 2>/dev/null | awk -v svc="$SERVICE" '
        /0x00000007.*="'"$SERVICE"'"/ { found=1 }
        found && /"acct"/ {
            gsub(/.*<blob>="/, "  ")
            gsub(/"$/, "")
            print
            found=0
        }
    ' | sort -u

    log_access "LIST" "-" "success"
}

cmd_delete() {
    local name="$1"

    if [[ -z "$name" ]]; then
        echo "Usage: secret-lover delete NAME" >&2
        exit 1
    fi

    if security delete-generic-password -a "$name" -s "$SERVICE" >/dev/null 2>&1; then
        log_access "DELETE" "$name" "success"
        echo "✓ Deleted: $name"
    else
        log_access "DELETE" "$name" "not_found"
        echo "✗ Secret '$name' not found" >&2
        exit 1
    fi
}

cmd_check() {
    echo "Checking Touch ID availability..."

    # Check if biometrics are available
    if bioutil -r 2>/dev/null | grep -q "Touch ID"; then
        echo "✓ Touch ID is available"
    elif bioutil -r 2>/dev/null | grep -q "biometry"; then
        echo "✓ Biometric authentication available"
    else
        echo "⚠ Touch ID not detected (password auth will be used)"
    fi

    # Check keychain access
    echo
    echo "Testing Keychain access..."
    local test_name="_secret_lover_test_$$"

    if security add-generic-password -a "$test_name" -s "$SERVICE" -w "test" -T "" 2>/dev/null; then
        security delete-generic-password -a "$test_name" -s "$SERVICE" 2>/dev/null
        echo "✓ Keychain read/write working"
    else
        echo "✗ Keychain access failed" >&2
        exit 1
    fi

    echo
    echo "All checks passed!"
}

cmd_init() {
    local secrets_file=".secrets.json"

    if [[ -f "$secrets_file" ]]; then
        echo "⚠ $secrets_file already exists" >&2
        exit 1
    fi

    cat > "$secrets_file" << 'EOF'
{
  "_note": "Secrets stored in macOS Keychain. Run: secret-lover run -- <command>",
  "secrets": {
    "EXAMPLE_API_KEY": "Description of this secret"
  }
}
EOF

    echo "✓ Created $secrets_file"
    echo "  Edit to add your project's secrets, then run:"
    echo "  secret-lover add EXAMPLE_API_KEY"
}

cmd_verify() {
    local secrets_file
    secrets_file=$(find_secrets_file)

    if [[ -z "$secrets_file" ]]; then
        echo "Error: No .secrets.json found in current directory or parents" >&2
        exit 1
    fi

    echo "Checking secrets from: $secrets_file"
    echo

    local missing=0
    local found=0

    # Parse secret names from JSON
    local names
    names=$(grep -o '"[A-Z_][A-Z0-9_]*":' "$secrets_file" | tr -d '":' | grep -v "^_")

    for name in $names; do
        if security find-generic-password -a "$name" -s "$SERVICE" 2>/dev/null >/dev/null; then
            echo "  ✓ $name"
            ((found++))
        else
            echo "  ✗ $name (missing)"
            ((missing++))
        fi
    done

    echo
    if [[ $missing -eq 0 ]]; then
        echo "All $found secrets found in Keychain!"
    else
        echo "$missing secret(s) missing. Add them with:"
        echo "  secret-lover add NAME"
        exit 1
    fi
}

find_secrets_file() {
    local dir="$PWD"
    while [[ "$dir" != "/" ]]; do
        if [[ -f "$dir/.secrets.json" ]]; then
            echo "$dir/.secrets.json"
            return 0
        fi
        dir=$(dirname "$dir")
    done
    return 1
}

cmd_run() {
    # Skip the -- separator if present
    if [[ "$1" == "--" ]]; then
        shift
    fi

    if [[ $# -eq 0 ]]; then
        echo "Usage: secret-lover run -- <command>" >&2
        exit 1
    fi

    local secrets_file
    secrets_file=$(find_secrets_file)

    if [[ -z "$secrets_file" ]]; then
        echo "Error: No .secrets.json found in current directory or parents" >&2
        echo "Run 'secret-lover init' to create one" >&2
        exit 1
    fi

    # Parse secret names from JSON
    local names
    names=$(grep -o '"[A-Z_][A-Z0-9_]*":' "$secrets_file" | tr -d '":' | grep -v "^_")

    # Build environment
    local env_vars=()
    local missing=()

    for name in $names; do
        local value
        if value=$(security find-generic-password -a "$name" -s "$SERVICE" -w 2>/dev/null); then
            env_vars+=("$name=$value")
            log_access "INJECT" "$name" "success"
        else
            missing+=("$name")
        fi
    done

    if [[ ${#missing[@]} -gt 0 ]]; then
        echo "Error: Missing secrets in Keychain:" >&2
        printf '  %s\n' "${missing[@]}" >&2
        echo "Add them with: secret-lover add NAME" >&2
        exit 1
    fi

    # Execute command with secrets injected via subshell with exports
    log_access "RUN" "$(basename "$1")" "executing"
    (
        for var in "${env_vars[@]}"; do
            export "$var"
        done
        "$@"
    )
}

# Main dispatch
case "${1:-help}" in
    add)
        shift
        cmd_add "$@"
        ;;
    get)
        shift
        cmd_get "$@"
        ;;
    list)
        cmd_list
        ;;
    delete|remove|rm)
        shift
        cmd_delete "$@"
        ;;
    check|test)
        cmd_check
        ;;
    init)
        cmd_init
        ;;
    verify|check-project)
        cmd_verify
        ;;
    run|exec)
        shift
        cmd_run "$@"
        ;;
    help|--help|-h)
        show_help
        ;;
    *)
        echo "Unknown command: $1" >&2
        echo "Run 'secret-lover help' for usage" >&2
        exit 1
        ;;
esac
