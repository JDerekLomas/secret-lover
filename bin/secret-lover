#!/bin/bash
#
# secret-lover - The one who keeps your secrets
# Credential broker for macOS Keychain with Touch ID
# Supports project namespacing for per-project secrets
#

set -e

SERVICE_BASE="secret-lover"
LOG_DIR="$HOME/.secret-lover"
LOG_FILE="$LOG_DIR/access.log"

# Find the keychain helper (Touch ID support)
SCRIPT_DIR="$(cd "$(dirname "$(readlink "$0" 2>/dev/null || echo "$0")")" && pwd)"
HELPER="$SCRIPT_DIR/keychain-helper"

# Auth session cache (avoids multiple prompts within window)
AUTH_CACHE_FILE="$LOG_DIR/.auth_session"
AUTH_CACHE_SECONDS=60

# Ensure log directory exists
mkdir -p "$LOG_DIR"

# Global variables set by detect_project
PROJECT=""
SERVICE="$SERVICE_BASE"

# Check if auth session is still valid
is_auth_cached() {
    if [[ -f "$AUTH_CACHE_FILE" ]]; then
        local cached_time
        cached_time=$(cat "$AUTH_CACHE_FILE" 2>/dev/null)
        local now
        now=$(date +%s)
        if [[ -n "$cached_time" ]] && (( now - cached_time < AUTH_CACHE_SECONDS )); then
            return 0
        fi
    fi
    return 1
}

# Update auth cache after successful authentication
update_auth_cache() {
    date +%s > "$AUTH_CACHE_FILE"
    chmod 600 "$AUTH_CACHE_FILE"
}

log_access() {
    local action="$1"
    local name="$2"
    local status="$3"
    local tty_name
    tty_name=$(tty 2>/dev/null) || tty_name="none"
    local project_info=""
    [[ -n "$PROJECT" ]] && project_info=" | project=$PROJECT"
    echo "$(date -Iseconds) | $action | $name | $status | pid=$$${project_info}" >> "$LOG_FILE"
}

# Detect project from .secrets.json or directory name
detect_project() {
    local secrets_file
    secrets_file=$(find_secrets_file 2>/dev/null) || true

    if [[ -n "$secrets_file" ]]; then
        # Try to get project from .secrets.json
        local json_project
        json_project=$(grep -o '"project"[[:space:]]*:[[:space:]]*"[^"]*"' "$secrets_file" 2>/dev/null | sed 's/.*: *"\([^"]*\)"/\1/' || true)

        if [[ -n "$json_project" ]]; then
            PROJECT="$json_project"
        else
            # Use directory name containing .secrets.json
            PROJECT=$(basename "$(dirname "$secrets_file")")
        fi
    fi

    # Set service name based on project
    if [[ -n "$PROJECT" ]]; then
        SERVICE="$SERVICE_BASE/$PROJECT"
    fi
}

find_secrets_file() {
    local dir="$PWD"
    while [[ "$dir" != "/" ]]; do
        if [[ -f "$dir/.secrets.json" ]]; then
            echo "$dir/.secrets.json"
            return 0
        fi
        dir=$(dirname "$dir")
    done
    return 1
}

# Check if secret exists (no auth, for verification)
secret_exists() {
    local name="$1"

    if [[ -x "$HELPER" ]]; then
        # Use non-auth get to check existence
        if [[ -n "$PROJECT" ]]; then
            "$HELPER" get "$name" "$PROJECT" >/dev/null 2>&1 && return 0
        fi
        "$HELPER" get "$name" >/dev/null 2>&1 && return 0
        return 1
    fi

    # Fallback to security CLI
    if [[ -n "$PROJECT" ]]; then
        security find-generic-password -a "$name" -s "$SERVICE_BASE/$PROJECT" -w >/dev/null 2>&1 && return 0
    fi
    security find-generic-password -a "$name" -s "$SERVICE_BASE" -w >/dev/null 2>&1 && return 0
    return 1
}

# Get secret with fallback: project-specific -> global
# Uses Touch ID if helper is available (with session caching)
get_secret() {
    local name="$1"
    local use_auth="${2:-true}"  # Default to Touch ID auth
    local value

    # Use helper if available (Touch ID support)
    if [[ -x "$HELPER" ]]; then
        local cmd="get"

        # Determine auth mode: use cache if available, otherwise prompt
        if [[ "$use_auth" == "true" ]]; then
            if is_auth_cached; then
                # Use non-auth get since we have a recent auth
                cmd="get"
            else
                cmd="get-auth"
            fi
        fi

        if [[ -n "$PROJECT" ]]; then
            if value=$("$HELPER" "$cmd" "$name" "$PROJECT" 2>/dev/null); then
                [[ "$cmd" == "get-auth" ]] && update_auth_cache
                echo "$value"
                return 0
            fi
        fi
        # Fallback to global
        if value=$("$HELPER" "$cmd" "$name" 2>/dev/null); then
            [[ "$cmd" == "get-auth" ]] && update_auth_cache
            echo "$value"
            return 0
        fi
        return 1
    fi

    # Fallback to security CLI (no Touch ID)
    if [[ -n "$PROJECT" ]]; then
        if value=$(security find-generic-password -a "$name" -s "$SERVICE_BASE/$PROJECT" -w 2>/dev/null); then
            echo "$value"
            return 0
        fi
    fi

    if value=$(security find-generic-password -a "$name" -s "$SERVICE_BASE" -w 2>/dev/null); then
        echo "$value"
        return 0
    fi

    return 1
}

show_help() {
    cat << 'EOF'
secret-lover - The one who keeps your secrets

COMMANDS:
  secret-lover add NAME [VALUE]        Add a secret (prompts if VALUE omitted)
  secret-lover add NAME --global       Add as global (not project-specific)
  secret-lover get NAME                Retrieve a secret (requires Touch ID)
  secret-lover list                    List all stored secret names
  secret-lover list --all              List secrets for all projects
  secret-lover delete NAME             Remove a secret
  secret-lover check                   Check if Touch ID is available
  secret-lover clear-auth              Clear auth session (force re-auth)
  secret-lover migrate                 Re-save existing secrets with Touch ID
  secret-lover help                    Show this help

PROJECT COMMANDS:
  secret-lover run -- <command>        Run command with .secrets.json injected
  secret-lover init [PROJECT]          Create .secrets.json template
  secret-lover verify                  Check all project secrets exist

PROJECT NAMESPACING:
  Secrets are stored per-project by default. Project is auto-detected from:
  1. "project" field in .secrets.json
  2. Directory name containing .secrets.json

  When retrieving, falls back to global secrets if no project-specific found.

EXAMPLES:
  # In ~/myproject with .secrets.json
  secret-lover add SUPABASE_URL        # Stored for "myproject"
  secret-lover add OPENAI_KEY --global # Stored globally (shared)

  # Different projects can have different SUPABASE_URLs
  cd ~/projectA && secret-lover add SUPABASE_URL "https://a.supabase.co"
  cd ~/projectB && secret-lover add SUPABASE_URL "https://b.supabase.co"

AUTH SESSION:
  - Authentication is cached for 60 seconds to avoid repeated prompts
  - Use 'clear-auth' to force re-authentication

SECURITY:
  - Secrets stored in macOS Keychain (login keychain)
  - Touch ID or password required for retrieval
  - All access logged to ~/.secret-lover/access.log
  - Secrets never written to disk or shell history

EOF
}

cmd_add() {
    local name=""
    local value=""
    local global=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --global|-g)
                global=true
                shift
                ;;
            *)
                if [[ -z "$name" ]]; then
                    name="$1"
                elif [[ -z "$value" ]]; then
                    value="$1"
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$name" ]]; then
        echo "Usage: secret-lover add NAME [VALUE] [--global]" >&2
        exit 1
    fi

    # Detect project unless --global
    if ! $global; then
        detect_project
    fi

    # If no value provided, prompt securely
    if [[ -z "$value" ]]; then
        local prompt="Enter value for $name"
        [[ -n "$PROJECT" ]] && prompt="$prompt (project: $PROJECT)"
        echo -n "$prompt: "
        read -s value
        echo

        if [[ -z "$value" ]]; then
            echo "Error: Empty value not allowed" >&2
            exit 1
        fi
    fi

    # Add to keychain using helper (Touch ID) or security CLI
    local success=false
    if [[ -x "$HELPER" ]]; then
        if [[ -n "$PROJECT" ]] && ! $global; then
            "$HELPER" add "$name" "$value" "$PROJECT" >/dev/null 2>&1 && success=true
        else
            "$HELPER" add "$name" "$value" >/dev/null 2>&1 && success=true
        fi
    else
        # Fallback to security CLI
        security delete-generic-password -a "$name" -s "$SERVICE" 2>/dev/null || true
        security add-generic-password -a "$name" -s "$SERVICE" -w "$value" -T "" 2>/dev/null && success=true
    fi

    if $success; then
        log_access "ADD" "$name" "success"
        if [[ -n "$PROJECT" ]] && ! $global; then
            echo "✓ Stored: $name (project: $PROJECT)"
        else
            echo "✓ Stored: $name (global)"
        fi
    else
        log_access "ADD" "$name" "failed"
        echo "✗ Failed to store: $name" >&2
        exit 1
    fi
}

cmd_get() {
    local name="$1"

    if [[ -z "$name" ]]; then
        echo "Usage: secret-lover get NAME" >&2
        exit 1
    fi

    detect_project

    local value
    if value=$(get_secret "$name"); then
        log_access "GET" "$name" "success"
        echo "$value"
    else
        log_access "GET" "$name" "not_found"
        echo "Error: Secret '$name' not found" >&2
        [[ -n "$PROJECT" ]] && echo "  (checked project '$PROJECT' and global)" >&2
        exit 1
    fi
}

cmd_list() {
    local show_all=false
    [[ "$1" == "--all" || "$1" == "-a" ]] && show_all=true

    detect_project

    if [[ -x "$HELPER" ]]; then
        # Use helper for listing
        if $show_all; then
            echo "All secrets in Keychain:"
            echo
            "$HELPER" list-all | while IFS=$'\t' read -r name proj; do
                if [[ "$proj" == "global" ]]; then
                    echo "  $name (global)"
                else
                    echo "  $name ($proj)"
                fi
            done | sort
        else
            if [[ -n "$PROJECT" ]]; then
                echo "Secrets for project '$PROJECT':"
            else
                echo "Global secrets:"
            fi
            echo

            if [[ -n "$PROJECT" ]]; then
                "$HELPER" list "$PROJECT" | while read -r name; do
                    echo "  $name"
                done
            else
                "$HELPER" list | while read -r name; do
                    echo "  $name"
                done
            fi

            if [[ -n "$PROJECT" ]]; then
                echo
                echo "Also inherits global secrets (use --all to see)"
            fi
        fi
    else
        # Fallback to security CLI
        if $show_all; then
            echo "All secrets in Keychain:"
            echo
            security dump-keychain 2>/dev/null | awk '
                /0x00000007.*="secret-lover/ {
                    match($0, /"secret-lover[^"]*"/)
                    svc = substr($0, RSTART+1, RLENGTH-2)
                    found=1
                }
                found && /"acct"/ {
                    match($0, /<blob>="[^"]*"/)
                    name = substr($0, RSTART+8, RLENGTH-9)
                    if (svc == "secret-lover") {
                        print "  " name " (global)"
                    } else {
                        proj = substr(svc, 14)
                        print "  " name " (" proj ")"
                    }
                    found=0
                }
            ' | sort
        else
            if [[ -n "$PROJECT" ]]; then
                echo "Secrets for project '$PROJECT':"
            else
                echo "Global secrets:"
            fi
            echo

            local escaped_service="${SERVICE//\//\\/}"
            security dump-keychain 2>/dev/null | awk -v svc="$SERVICE" '
                /0x00000007.*="'"$escaped_service"'"/ { found=1 }
                found && /"acct"/ {
                    gsub(/.*<blob>="/, "  ")
                    gsub(/"$/, "")
                    print
                    found=0
                }
            ' | sort -u

            if [[ -n "$PROJECT" ]]; then
                echo
                echo "Also inherits global secrets (use --all to see)"
            fi
        fi
    fi

    log_access "LIST" "-" "success"
}

cmd_delete() {
    local name="$1"

    if [[ -z "$name" ]]; then
        echo "Usage: secret-lover delete NAME" >&2
        exit 1
    fi

    detect_project

    local deleted=false

    if [[ -x "$HELPER" ]]; then
        # Try project-specific first
        if [[ -n "$PROJECT" ]] && "$HELPER" delete "$name" "$PROJECT" >/dev/null 2>&1; then
            log_access "DELETE" "$name" "success"
            echo "✓ Deleted: $name (project: $PROJECT)"
            deleted=true
        elif "$HELPER" delete "$name" >/dev/null 2>&1; then
            log_access "DELETE" "$name" "success (global)"
            echo "✓ Deleted: $name (global)"
            deleted=true
        fi
    else
        # Fallback to security CLI
        if security delete-generic-password -a "$name" -s "$SERVICE" >/dev/null 2>&1; then
            log_access "DELETE" "$name" "success"
            if [[ -n "$PROJECT" ]]; then
                echo "✓ Deleted: $name (project: $PROJECT)"
            else
                echo "✓ Deleted: $name (global)"
            fi
            deleted=true
        elif [[ -n "$PROJECT" ]] && security delete-generic-password -a "$name" -s "$SERVICE_BASE" >/dev/null 2>&1; then
            log_access "DELETE" "$name" "success (global)"
            echo "✓ Deleted: $name (global)"
            deleted=true
        fi
    fi

    if ! $deleted; then
        log_access "DELETE" "$name" "not_found"
        echo "✗ Secret '$name' not found" >&2
        exit 1
    fi
}

cmd_clear_auth() {
    if [[ -f "$AUTH_CACHE_FILE" ]]; then
        rm -f "$AUTH_CACHE_FILE"
        echo "✓ Auth session cleared"
    else
        echo "No active auth session"
    fi
}

cmd_check() {
    echo "Checking Touch ID availability..."

    if bioutil -r 2>/dev/null | grep -q "Touch ID"; then
        echo "✓ Touch ID is available"
    elif bioutil -r 2>/dev/null | grep -q "biometry"; then
        echo "✓ Biometric authentication available"
    else
        echo "⚠ Touch ID not detected (password auth will be used)"
    fi

    echo
    echo "Testing Keychain access..."
    local test_name="_secret_lover_test_$$"

    if security add-generic-password -a "$test_name" -s "$SERVICE_BASE" -w "test" -T "" 2>/dev/null; then
        security delete-generic-password -a "$test_name" -s "$SERVICE_BASE" 2>/dev/null
        echo "✓ Keychain read/write working"
    else
        echo "✗ Keychain access failed" >&2
        exit 1
    fi

    echo
    echo "All checks passed!"
}

cmd_init() {
    local project_name="${1:-$(basename "$PWD")}"
    local secrets_file=".secrets.json"

    if [[ -f "$secrets_file" ]]; then
        echo "⚠ $secrets_file already exists" >&2
        exit 1
    fi

    cat > "$secrets_file" << EOF
{
  "project": "$project_name",
  "secrets": [
    "EXAMPLE_API_KEY"
  ],
  "env": {}
}
EOF

    echo "✓ Created $secrets_file for project '$project_name'"
    echo "  Edit to add your secret names to the \"secrets\" array, then run:"
    echo "  secret-lover add EXAMPLE_API_KEY"
}

cmd_verify() {
    local secrets_file
    secrets_file=$(find_secrets_file)

    if [[ -z "$secrets_file" ]]; then
        echo "Error: No .secrets.json found in current directory or parents" >&2
        exit 1
    fi

    detect_project

    echo "Checking secrets from: $secrets_file"
    [[ -n "$PROJECT" ]] && echo "Project: $PROJECT"
    echo

    local missing=0
    local found=0

    # Parse keychain secret names from "secrets" array
    local keychain_names
    keychain_names=$(python3 -c "
import json, sys
with open('$secrets_file') as f:
    data = json.load(f)
for name in data.get('secrets', []):
    print(name)
" 2>/dev/null)

    # Parse static env var names from "env" object
    local env_names
    env_names=$(python3 -c "
import json, sys
with open('$secrets_file') as f:
    data = json.load(f)
for name in data.get('env', {}).keys():
    print(name)
" 2>/dev/null)

    # Check keychain secrets
    for name in $keychain_names; do
        if secret_exists "$name"; then
            if [[ -n "$PROJECT" ]]; then
                if [[ -x "$HELPER" ]] && "$HELPER" get "$name" "$PROJECT" >/dev/null 2>&1; then
                    echo "  ✓ $name (keychain/project)"
                elif security find-generic-password -a "$name" -s "$SERVICE" -w >/dev/null 2>&1; then
                    echo "  ✓ $name (keychain/project)"
                else
                    echo "  ✓ $name (keychain/global)"
                fi
            else
                echo "  ✓ $name (keychain)"
            fi
            ((found++))
        else
            echo "  ✗ $name (missing from keychain)"
            ((missing++))
        fi
    done

    # Check static env vars (always present if in file)
    for name in $env_names; do
        echo "  ✓ $name (env)"
        ((found++))
    done

    echo
    if [[ $missing -eq 0 ]]; then
        echo "All $found secrets found!"
    else
        echo "$missing secret(s) missing. Add them with:"
        echo "  secret-lover add NAME"
        exit 1
    fi
}

cmd_run() {
    # Skip the -- separator if present
    if [[ "$1" == "--" ]]; then
        shift
    fi

    if [[ $# -eq 0 ]]; then
        echo "Usage: secret-lover run -- <command>" >&2
        exit 1
    fi

    local secrets_file
    secrets_file=$(find_secrets_file)

    if [[ -z "$secrets_file" ]]; then
        echo "Error: No .secrets.json found in current directory or parents" >&2
        echo "Run 'secret-lover init' to create one" >&2
        exit 1
    fi

    detect_project

    # Build environment
    local env_vars=()
    local missing=()

    # 1. Inject keychain secrets from "secrets" array
    local keychain_names
    keychain_names=$(python3 -c "
import json, sys
with open('$secrets_file') as f:
    data = json.load(f)
for name in data.get('secrets', []):
    print(name)
" 2>/dev/null)

    for name in $keychain_names; do
        local value
        if value=$(get_secret "$name"); then
            env_vars+=("$name=$value")
            log_access "INJECT" "$name" "success"
        else
            missing+=("$name")
        fi
    done

    if [[ ${#missing[@]} -gt 0 ]]; then
        echo "Warning: ${#missing[@]} secret(s) not in Keychain (skipping):" >&2
        printf '  %s\n' "${missing[@]}" >&2
    fi

    # 2. Inject static env vars from "env" object
    local env_pairs
    env_pairs=$(python3 -c "
import json, sys
with open('$secrets_file') as f:
    data = json.load(f)
for k, v in data.get('env', {}).items():
    print(f'{k}={v}')
" 2>/dev/null)

    while IFS= read -r pair; do
        [[ -n "$pair" ]] && env_vars+=("$pair")
    done <<< "$env_pairs"

    # Execute command with secrets injected via subshell with exports
    log_access "RUN" "$(basename "$1")" "executing"
    (
        for var in "${env_vars[@]}"; do
            export "$var"
        done
        "$@"
    )
}

cmd_migrate() {
    echo "Migrating secrets to Touch ID..."
    echo

    if [[ ! -x "$HELPER" ]]; then
        echo "Error: keychain-helper not found at $HELPER" >&2
        echo "Touch ID migration requires the helper binary." >&2
        exit 1
    fi

    local count=0
    local failed=0

    # Get all secrets using security CLI (old format)
    while IFS=$'\t' read -r name svc; do
        [[ -z "$name" ]] && continue

        # Read value using security CLI
        local value
        if value=$(security find-generic-password -a "$name" -s "$svc" -w 2>/dev/null); then
            # Determine project
            local project=""
            if [[ "$svc" != "secret-lover" ]]; then
                project="${svc#secret-lover/}"
            fi

            # Delete old item using security CLI (same tool that created it)
            security delete-generic-password -a "$name" -s "$svc" >/dev/null 2>&1 || true

            # Re-save with helper (Touch ID enabled)
            local label="global"
            [[ -n "$project" ]] && label="$project"

            if [[ -n "$project" ]]; then
                if "$HELPER" add "$name" "$value" "$project" >/dev/null 2>&1; then
                    echo "  ✓ $name ($label)"
                    ((count++))
                else
                    echo "  ✗ $name ($label) - failed to add"
                    ((failed++))
                fi
            else
                if "$HELPER" add "$name" "$value" >/dev/null 2>&1; then
                    echo "  ✓ $name ($label)"
                    ((count++))
                else
                    echo "  ✗ $name ($label) - failed to add"
                    ((failed++))
                fi
            fi
        else
            # Determine project for error message
            local label="global"
            [[ "$svc" != "secret-lover" ]] && label="${svc#secret-lover/}"
            echo "  ✗ $name ($label) - failed to read"
            ((failed++))
        fi
    done < <(security dump-keychain 2>/dev/null | awk '
        /0x00000007.*="secret-lover/ {
            match($0, /"secret-lover[^"]*"/)
            svc = substr($0, RSTART+1, RLENGTH-2)
            found=1
        }
        found && /"acct"/ {
            match($0, /<blob>="[^"]*"/)
            name = substr($0, RSTART+8, RLENGTH-9)
            print name "\t" svc
            found=0
        }
    ')

    echo
    if [[ $failed -eq 0 ]]; then
        echo "Migrated $count secrets to Touch ID!"
    else
        echo "Migrated $count secrets, $failed failed."
        exit 1
    fi
}

# Main dispatch
case "${1:-help}" in
    add)
        shift
        cmd_add "$@"
        ;;
    get)
        shift
        cmd_get "$@"
        ;;
    list|ls)
        shift
        cmd_list "$@"
        ;;
    delete|remove|rm)
        shift
        cmd_delete "$@"
        ;;
    check|test)
        cmd_check
        ;;
    clear-auth)
        cmd_clear_auth
        ;;
    init)
        shift
        cmd_init "$@"
        ;;
    verify|check-project)
        cmd_verify
        ;;
    migrate)
        cmd_migrate
        ;;
    run|exec)
        shift
        cmd_run "$@"
        ;;
    help|--help|-h)
        show_help
        ;;
    *)
        echo "Unknown command: $1" >&2
        echo "Run 'secret-lover help' for usage" >&2
        exit 1
        ;;
esac
